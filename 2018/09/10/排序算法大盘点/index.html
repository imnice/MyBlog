<!DOCTYPE html>
<html class="has-navbar-fixed-top">
<head>
    <meta charset="utf-8">
<title>排序算法盘点 - LSB.pro</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.css">




<meta name="description" content="排序算法大盘点#文章摘要，会出现在meta的description里面<!--more-->">



<meta name="keywords" content="NB!">



    <meta name="description" content="排序算法大盘点#文章摘要，会出现在meta的description里面">
<meta name="keywords" content="面试题,算法">
<meta property="og:type" content="article">
<meta property="og:title" content="排序算法盘点">
<meta property="og:url" content="https://imnice.github.io/2018/09/10/排序算法大盘点/index.html">
<meta property="og:site_name" content="LSB.pro">
<meta property="og:description" content="排序算法大盘点#文章摘要，会出现在meta的description里面">
<meta property="og:locale" content="zh-cn">
<meta property="og:image" content="http://r.photo.store.qq.com/psb?/932c31e8-a24c-44e8-b0eb-07a959965080/NxHAz3ENVHfjVL0CDc6Gr6aOtD5Jn5K6dlZKOCvQIZ0!/r/dDEBAAAAAAAA">
<meta property="og:image" content="http://m.qpic.cn/psb?/932c31e8-a24c-44e8-b0eb-07a959965080/YV9tnBeeATgqzB5xz36IXrPQhJQq4jtJ*LIxXPqCMPU!/b/dFIBAAAAAAAA&bo=KwP4ACsD.AACSW0!&rf=viewer_4">
<meta property="og:image" content="http://m.qpic.cn/psb?/932c31e8-a24c-44e8-b0eb-07a959965080/zL5OCxqeFlrhi4Yvqt7hV7IlHGYOBaDEfdlwHByFmIo!/b/dDUBAAAAAAAA&bo=KwP5ASsD.QECOR0!&rf=viewer_4">
<meta property="og:image" content="http://m.qpic.cn/psb?/932c31e8-a24c-44e8-b0eb-07a959965080/aOGOUsorlHlBsmkCLfRocLV4iAjHHSdSTyuDwMWfRVE!/b/dDUBAAAAAAAA&bo=OgMBAToDAQECOR0!&rf=viewer_4">
<meta property="og:image" content="http://m.qpic.cn/psb?/932c31e8-a24c-44e8-b0eb-07a959965080/WbpvOOUMKcbzCu*7ExpJMjzqcof2U69m1jwix.iIJDs!/b/dEcBAAAAAAAA&bo=mQIiAZkCIgECaU0!&rf=viewer_4">
<meta property="og:image" content="http://m.qpic.cn/psb?/932c31e8-a24c-44e8-b0eb-07a959965080/derTFgU.GPvvPdOzG61BA3nh0vlHtER2WB4A8xwjgF4!/b/dDIBAAAAAAAA&bo=KwP5ASsD.QECOR0!&rf=viewer_4">
<meta property="og:image" content="http://m.qpic.cn/psb?/932c31e8-a24c-44e8-b0eb-07a959965080/pd5IzBeVhNW4VOXFht36KEbPCnPd.qhaH7i2tirsEZE!/b/dFUAAAAAAAAA&bo=KwP8ACsD*AACOR0!&rf=viewer_4">
<meta property="og:image" content="http://r.photo.store.qq.com/psb?/932c31e8-a24c-44e8-b0eb-07a959965080/qOx3ZGM.Q7rctahPmjDSgEtPW9ElmIUxwjcdSmHQpV4!/r/dFIBAAAAAAAA">
<meta property="og:image" content="http://r.photo.store.qq.com/psb?/932c31e8-a24c-44e8-b0eb-07a959965080/yVHsV635.YSKc8pNUwGU*kbQTlj.MyOwIl5ihuAjKL4!/r/dFIBAAAAAAAA">
<meta property="og:image" content="http://r.photo.store.qq.com/psb?/932c31e8-a24c-44e8-b0eb-07a959965080/SJnsOdMESxzcanQb5Zff9m1PWcvETjWcZqUhzOG8LrY!/r/dDQBAAAAAAAA">
<meta property="og:image" content="http://r.photo.store.qq.com/psb?/932c31e8-a24c-44e8-b0eb-07a959965080/P1R6qKYyIG2cvmg4iwq311KwKxl3kHHtkQASAay.YyQ!/r/dFIBAAAAAAAA">
<meta property="og:image" content="http://r.photo.store.qq.com/psb?/932c31e8-a24c-44e8-b0eb-07a959965080/Q2F4.olX0m5xGkcelT5Zl7kkA62Qv9sWv.oIAEKKf7E!/r/dDYBAAAAAAAA">
<meta property="og:updated_time" content="2018-09-19T14:25:27.942Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="排序算法盘点">
<meta name="twitter:description" content="排序算法大盘点#文章摘要，会出现在meta的description里面">
<meta name="twitter:image" content="http://r.photo.store.qq.com/psb?/932c31e8-a24c-44e8-b0eb-07a959965080/NxHAz3ENVHfjVL0CDc6Gr6aOtD5Jn5K6dlZKOCvQIZ0!/r/dDEBAAAAAAAA">





<link rel="icon" href="/favicon.png">


<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Ovo|Source+Code+Pro">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/bulma/0.6.2/css/bulma.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/css/justifiedGallery.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css">

<link rel="stylesheet" href="/css/style.css">

<script defer src="//use.fontawesome.com/releases/v5.0.8/js/all.js"></script>


    
    
    
    
    
    
    
    
    
    

    


</head>
<body>
    
<nav class="navbar is-transparent is-fixed-top navbar-main" role="navigation" aria-label="main navigation">
    <div class="container">
        <div class="navbar-brand">
            <a class="navbar-item navbar-logo" href="/">
                
                    
                    LSB.pro
                    
                
            </a>
            <div class="navbar-burger">
                <span></span>
                <span></span>
                <span></span>
            </div>
        </div>
        
        <div class="navbar-menu navbar-start">
            
            <a class="navbar-item "
               href="/">Home</a>
            
            <a class="navbar-item "
               href="/archives">Archives</a>
            
            <a class="navbar-item "
               href="/tags">Tags</a>
            
            <a class="navbar-item "
               href="/categories">Categories</a>
            
            <a class="navbar-item "
               href="/about">About</a>
            
        </div>
        
        <div class="navbar-menu navbar-end">
            
            <a class="navbar-item search" title="搜索" href="javascript:;">
                <i class="fas fa-search"></i>
            </a>
            
            
            <div class="navbar-item is-hoverable has-dropdown is-hidden-mobile is-hidden-tablet-only toc">
                <a class="navbar-item" title="目录">
                    <i class="fa fa-list"></i>
                </a>
                <div class="navbar-dropdown is-right">
                    
                    
                    
                    
                    <a class="navbar-item" href="#各种排序算法大比武">1&nbsp;&nbsp;<b>各种排序算法大比武</b></a>
                    
                    
                    <hr class="navbar-divider">
                    
                    
                    <a class="navbar-item" href="#选择排序（Selection-Sort）">2&nbsp;&nbsp;<b>选择排序（Selection Sort）</b></a>
                    
                    
                    <hr class="navbar-divider">
                    
                    
                    <a class="navbar-item" href="#插入排序（Insertion-Sort）">3&nbsp;&nbsp;<b>插入排序（Insertion Sort）</b></a>
                    
                    
                    <hr class="navbar-divider">
                    
                    
                    <a class="navbar-item" href="#冒泡排序（Bubble-Sort）">4&nbsp;&nbsp;<b>冒泡排序（Bubble Sort）</b></a>
                    
                    
                    <hr class="navbar-divider">
                    
                    
                    <a class="navbar-item" href="#希尔排序（Shell-Sort）">5&nbsp;&nbsp;<b>希尔排序（Shell Sort）</b></a>
                    
                    
                    <hr class="navbar-divider">
                    
                    
                    <a class="navbar-item" href="#归并排序（Merge-Sort）">6&nbsp;&nbsp;<b>归并排序（Merge Sort）</b></a>
                    
                    
                    <hr class="navbar-divider">
                    
                    
                    <a class="navbar-item" href="#快速排序（Quick-Sort）">7&nbsp;&nbsp;<b>快速排序（Quick Sort）</b></a>
                    
                    
                    
                    <a class="navbar-item" href="#1-普通快速排序">7.1&nbsp;&nbsp;1. 普通快速排序</a>
                    
                    
                    
                    <a class="navbar-item" href="#2-双路快速排序">7.2&nbsp;&nbsp;2. 双路快速排序</a>
                    
                    
                    
                    <a class="navbar-item" href="#3-三路快速排序">7.3&nbsp;&nbsp;3. 三路快速排序</a>
                    
                    
                    <hr class="navbar-divider">
                    
                    
                    <a class="navbar-item" href="#堆排序（Heap-Sort）">8&nbsp;&nbsp;<b>堆排序（Heap Sort）</b></a>
                    
                    
                    
                    <a class="navbar-item" href="#1-堆">8.1&nbsp;&nbsp;1. 堆</a>
                    
                    
                    
                    <a class="navbar-item" href="#2-上浮和下沉">8.2&nbsp;&nbsp;2. 上浮和下沉</a>
                    
                    
                    
                    <a class="navbar-item" href="#3-插入元素">8.3&nbsp;&nbsp;3.插入元素</a>
                    
                    
                    
                    <a class="navbar-item" href="#4-删除最大元素">8.4&nbsp;&nbsp;4. 删除最大元素</a>
                    
                    
                    
                    <a class="navbar-item" href="#5-堆排序">8.5&nbsp;&nbsp;5. 堆排序</a>
                    
                    
                    
                    <a class="navbar-item" href="#6-堆排序的应用——Top-K问题">8.6&nbsp;&nbsp;6. 堆排序的应用——Top K问题</a>
                    
                    
                    <hr class="navbar-divider">
                    
                    
                    <a class="navbar-item" href="#计数排序">9&nbsp;&nbsp;<b>计数排序</b></a>
                    
                    
                    <hr class="navbar-divider">
                    
                    
                    <a class="navbar-item" href="#排序算法总结">10&nbsp;&nbsp;<b>排序算法总结</b></a>
                    
                </div>
            </div>
            
            
            <a class="navbar-item" title="GitHub" href="https://github.com/imnice">
                
                <i class="fab fa-github"></i>
                
            </a>
               
            <a class="navbar-item" title="Weibo" href="https://weibo.com">
                
                <i class="fab fa-weibo"></i>
                
            </a>
               
            <a class="navbar-item" title="E-mail" href="mailto:imdangerous@163.com">
                
                <i class="fas fa-envelope"></i>
                
            </a>
               
            
        </div>
    </div>
</nav>

    <section class="section">
    <div class="container">
    <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            排序算法盘点
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2018-09-10T10:00:50.000Z" itemprop="datePublished">9月 10 2018</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/默认分类/">默认分类</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            34 分钟 读完 (约 5043 字)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <p>算法第一课一般都是从排序算法开始讲起的，现在来稍微盘点一下各种排序算法。</p>
<a id="more"></a>
<h3 id="各种排序算法大比武"><a href="#各种排序算法大比武" class="headerlink" title="各种排序算法大比武"></a>各种排序算法大比武</h3><p><img src="http://r.photo.store.qq.com/psb?/932c31e8-a24c-44e8-b0eb-07a959965080/NxHAz3ENVHfjVL0CDc6Gr6aOtD5Jn5K6dlZKOCvQIZ0!/r/dDEBAAAAAAAA" alt="排序算法比较"> </p>
<h3 id="选择排序（Selection-Sort）"><a href="#选择排序（Selection-Sort）" class="headerlink" title="选择排序（Selection Sort）"></a>选择排序（Selection Sort）</h3><p>选择出数组中的最小元素，将它与数组的第一个元素交换位置。再从剩下的元素中选择出最小的元素，将它与数组的第二个元素交换位置。不断进行这样的操作，直到将整个数组排序。 </p>
<p><img src="http://m.qpic.cn/psb?/932c31e8-a24c-44e8-b0eb-07a959965080/YV9tnBeeATgqzB5xz36IXrPQhJQq4jtJ*LIxXPqCMPU!/b/dFIBAAAAAAAA&amp;bo=KwP4ACsD.AACSW0!&amp;rf=viewer_4" alt="选择排序"></p>
<p><strong>代码实现</strong></p>
<figure class="highlight java hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="hljs-comment">// 寻找[i, n)区间里的最小值的索引</span></span><br><span class="line">        <span class="hljs-keyword">int</span> minIndex = i;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span>(arr[minIndex] &gt; arr[j])&#123;</span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap( arr , i , minIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> t = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>算法分析</strong></p>
<p>表现最稳定的排序算法之一，因为无论什么数据进去都是O(n2)的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。</p>
<h3 id="插入排序（Insertion-Sort）"><a href="#插入排序（Insertion-Sort）" class="headerlink" title="插入排序（Insertion Sort）"></a>插入排序（Insertion Sort）</h3><p>插入排序从左到右进行，每次都将当前元素插入到左侧已经排序的数组中，使得插入之后左部数组依然有序。</p>
<p>第 j 元素是通过不断向左比较并交换来实现插入过程：当第 j 元素小于第 j - 1 元素，就将它们的位置交换，然后令 j 指针向左移动一个位置，不断进行以上操作。</p>
<p><img src="http://m.qpic.cn/psb?/932c31e8-a24c-44e8-b0eb-07a959965080/zL5OCxqeFlrhi4Yvqt7hV7IlHGYOBaDEfdlwHByFmIo!/b/dDUBAAAAAAAA&amp;bo=KwP5ASsD.QECOR0!&amp;rf=viewer_4" alt="插入排序"></p>
<p><strong>代码实现</strong></p>
<figure class="highlight java hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length - <span class="hljs-number">1</span>; i++) &#123;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &gt; <span class="hljs-number">0</span>; j--) &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (arr[j] &lt; arr[j - <span class="hljs-number">1</span>])</span><br><span class="line">                swap(arr, j, j - <span class="hljs-number">1</span>); <span class="hljs-comment">// 大量的交换会消耗时间</span></span><br><span class="line">            <span class="hljs-keyword">else</span></span><br><span class="line">                <span class="hljs-keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 改进版插入排序（减少了数组元素的操作次数）</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">better_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> e = arr[i];</span><br><span class="line">        <span class="hljs-keyword">int</span> j = i;</span><br><span class="line">        <span class="hljs-keyword">for</span> (; j &gt; <span class="hljs-number">0</span>; j--) &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (e &lt; arr[j - <span class="hljs-number">1</span>])</span><br><span class="line">                arr[j] = arr[j - <span class="hljs-number">1</span>];</span><br><span class="line">            <span class="hljs-keyword">else</span></span><br><span class="line">                <span class="hljs-keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j] = e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> t = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>算法分析</strong></p>
<p>插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p>
<h3 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h3><p>通过从左到右不断交换相邻逆序的相邻元素，在一轮的交换之后，可以让未排序的元素上浮到右侧。</p>
<p>在一轮循环中，如果没有发生交换，就说明数组已经是有序的，此时可以直接退出。</p>
<p><img src="http://m.qpic.cn/psb?/932c31e8-a24c-44e8-b0eb-07a959965080/aOGOUsorlHlBsmkCLfRocLV4iAjHHSdSTyuDwMWfRVE!/b/dDUBAAAAAAAA&amp;bo=OgMBAToDAQECOR0!&amp;rf=viewer_4" alt="冒泡排序"></p>
<p><strong>代码实现</strong></p>
<figure class="highlight java hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = arr.length - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123; <span class="hljs-comment">// 从最后一位开始确定</span></span><br><span class="line">        <span class="hljs-keyword">boolean</span> swapped = <span class="hljs-keyword">false</span>;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span>(arr[j] &gt; arr[j+<span class="hljs-number">1</span>])&#123;</span><br><span class="line">                swapped = <span class="hljs-keyword">true</span>;</span><br><span class="line">                swap(arr,j,j+<span class="hljs-number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">if</span>(!swapped)</span><br><span class="line">            <span class="hljs-keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> t = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="希尔排序（Shell-Sort）"><a href="#希尔排序（Shell-Sort）" class="headerlink" title="希尔排序（Shell Sort）"></a>希尔排序（Shell Sort）</h3><p>1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫<strong>缩小增量排序</strong>。</p>
<p><strong>算法描述</strong></p>
<p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p>
<ul>
<li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</li>
<li>按增量序列个数k，对序列进行k 趟排序；</li>
<li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li>
</ul>
<p><img src="http://m.qpic.cn/psb?/932c31e8-a24c-44e8-b0eb-07a959965080/WbpvOOUMKcbzCu*7ExpJMjzqcof2U69m1jwix.iIJDs!/b/dEcBAAAAAAAA&amp;bo=mQIiAZkCIgECaU0!&amp;rf=viewer_4" alt="希尔排序"></p>
<p><strong>代码实现</strong></p>
<figure class="highlight java hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">// 希尔排序</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> n = arr.length;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> h = n / <span class="hljs-number">2</span>; h &gt; <span class="hljs-number">0</span>; h = h / <span class="hljs-number">2</span>) &#123;</span><br><span class="line">        <span class="hljs-comment">// 内部是一个插入排序</span></span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i = i + h) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">int</span> e = arr[i];</span><br><span class="line">            <span class="hljs-keyword">int</span> j = i;</span><br><span class="line">            <span class="hljs-keyword">for</span> (; j &gt; <span class="hljs-number">0</span>; j = j - h) &#123;</span><br><span class="line">                <span class="hljs-keyword">if</span> (e &lt; arr[j - h])</span><br><span class="line">                    arr[j] = arr[j - h];</span><br><span class="line">                <span class="hljs-keyword">else</span></span><br><span class="line">                    <span class="hljs-keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j] = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 希尔排序2</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort2</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> n = arr.length;</span><br><span class="line">    <span class="hljs-comment">// 计算 increment sequence: 1, 4, 13, 40, 121, 364, 1093...</span></span><br><span class="line">    <span class="hljs-keyword">int</span> h = <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-keyword">while</span> (h &lt; n / <span class="hljs-number">3</span>) h = <span class="hljs-number">3</span> * h + <span class="hljs-number">1</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println(h);</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">while</span> (h &gt;= <span class="hljs-number">1</span>) &#123;</span><br><span class="line">        <span class="hljs-comment">// h-sort the array</span></span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = h; i &lt; n; i++) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="hljs-comment">// 对 arr[i], arr[i-h], arr[i-2*h], arr[i-3*h]... 使用插入排序</span></span><br><span class="line">            <span class="hljs-keyword">int</span> e = arr[i];</span><br><span class="line">            <span class="hljs-keyword">int</span> j = i;</span><br><span class="line">            <span class="hljs-keyword">for</span> (; j &gt;= h &amp;&amp; e &lt; arr[j - h]; j -= h)</span><br><span class="line">                arr[j] = arr[j - h];</span><br><span class="line">            arr[j] = e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        h /= <span class="hljs-number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>算法分析</strong></p>
<p>对于大规模的数组，插入排序很慢，因为它只能交换相邻的元素，每次只能将逆序数量减少 1。</p>
<p>希尔排序的出现就是为了改进插入排序的这种局限性，它通过交换不相邻的元素，每次可以将逆序数量减少大于 1。</p>
<p>希尔排序使用插入排序对间隔 h 的序列进行排序。通过不断减小 h，最后令 h=1，就可以使得整个数组是有序的。</p>
<h3 id="归并排序（Merge-Sort）"><a href="#归并排序（Merge-Sort）" class="headerlink" title="归并排序（Merge Sort）"></a>归并排序（Merge Sort）</h3><p>归并排序的思想是将数组分成两部分，分别进行排序，然后归并起来。把长度为n的输入序列分成两个长度为n/2的子序列；对这两个子序列分别采用归并排序；将两个排序好的子序列合并成一个最终的排序序列。</p>
<p><img src="http://m.qpic.cn/psb?/932c31e8-a24c-44e8-b0eb-07a959965080/derTFgU.GPvvPdOzG61BA3nh0vlHtER2WB4A8xwjgF4!/b/dDIBAAAAAAAA&amp;bo=KwP5ASsD.QECOR0!&amp;rf=viewer_4" alt="归并排序"></p>
<p><strong>代码实现</strong></p>
<blockquote>
<p>1.归并方法</p>
<p>归并方法将数组中两个已经排序的部分归并成一个。</p>
</blockquote>
<figure class="highlight java hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    __MergeSort(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">__MergeSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (l &gt;= r)</span><br><span class="line">        <span class="hljs-keyword">return</span>;</span><br><span class="line">    <span class="hljs-keyword">int</span> mid = (l + r) / <span class="hljs-number">2</span>;</span><br><span class="line">    __MergeSort(arr, l, mid);</span><br><span class="line">    __MergeSort(arr, mid + <span class="hljs-number">1</span>, r);</span><br><span class="line">    merge(arr, l, mid, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 将arr[l...mid]和arr[mid+1...r]两部分进行归并</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span>[] aux = Arrays.copyOfRange(arr, l, r + <span class="hljs-number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 初始化，i指向左半部分的起始索引位置l；j指向右半部分起始索引位置mid+1</span></span><br><span class="line">    <span class="hljs-keyword">int</span> i = l, j = mid + <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = l; k &lt;= r; k++) &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (i &gt; mid) &#123;  <span class="hljs-comment">// 如果左半部分元素已经全部处理完毕</span></span><br><span class="line">            arr[k] = aux[j - l];</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j &gt; r) &#123;   <span class="hljs-comment">// 如果右半部分元素已经全部处理完毕</span></span><br><span class="line">            arr[k] = aux[i - l];</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (aux[i - l] &lt; aux[j - l]) &#123;  <span class="hljs-comment">// 左半部分所指元素 &lt; 右半部分所指元素</span></span><br><span class="line">            arr[k] = aux[i - l];</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 左半部分所指元素 &gt;= 右半部分所指元素</span></span><br><span class="line">            arr[k] = aux[j - l];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>2.自底向上归并排序</p>
</blockquote>
<figure class="highlight java hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> N = arr.length;</span><br><span class="line">    <span class="hljs-keyword">int</span>[] aux = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N];</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> sz = <span class="hljs-number">1</span>; sz &lt; N; sz += sz)</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i + sz &lt; N; i += sz + sz)</span><br><span class="line">            merge(arr, i, i + sz - <span class="hljs-number">1</span>, Math.min(i + sz + sz - <span class="hljs-number">1</span>, N - <span class="hljs-number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="快速排序（Quick-Sort）"><a href="#快速排序（Quick-Sort）" class="headerlink" title="快速排序（Quick Sort）"></a>快速排序（Quick Sort）</h3><p>快速排序可以说是20世纪最伟大的算法之一了。相信都有所耳闻，它的速度也正如它的名字那样，是一个非常快的算法了。当然它也后期经过了不断的改进和优化，才被公认为是一个值得信任的非常优秀的算法。</p>
<p><img src="http://m.qpic.cn/psb?/932c31e8-a24c-44e8-b0eb-07a959965080/pd5IzBeVhNW4VOXFht36KEbPCnPd.qhaH7i2tirsEZE!/b/dFUAAAAAAAAA&amp;bo=KwP8ACsD*AACOR0!&amp;rf=viewer_4" alt="快速排序"></p>
<p><strong>代码实现</strong></p>
<h4 id="1-普通快速排序"><a href="#1-普通快速排序" class="headerlink" title="1. 普通快速排序"></a>1. 普通快速排序</h4><figure class="highlight java hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">// 递归使用快速排序,对arr[l...r]的范围进行排序</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">QuickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr,<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span>(l&gt;=r)</span><br><span class="line">        <span class="hljs-keyword">return</span>;</span><br><span class="line">    <span class="hljs-keyword">int</span> p = partition(arr,l,r);</span><br><span class="line">    QuickSort(arr,l,p-<span class="hljs-number">1</span>);</span><br><span class="line">    QuickSort(arr,p+<span class="hljs-number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 将数组通过p分割成两部分</span></span><br><span class="line"><span class="hljs-comment">// 对arr[l...r]部分进行partition操作</span></span><br><span class="line"><span class="hljs-comment">// 返回p, 使得arr[l...p-1] &lt; arr[p] ; arr[p+1...r] &gt; arr[p]</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    swap(arr, l, (<span class="hljs-keyword">int</span>) (Math.random() % (r - l + <span class="hljs-number">1</span>)) + l);  <span class="hljs-comment">// 加入这一行变成随机快速排序</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">int</span> v = arr[l];</span><br><span class="line">    <span class="hljs-keyword">int</span> j = l;</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = j +<span class="hljs-number">1</span>;i&lt;=r;i++)&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span>(arr[i] &lt; v)&#123;</span><br><span class="line">            j++;</span><br><span class="line">            swap(arr,i,j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr,l,j);</span><br><span class="line">    <span class="hljs-keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr,<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>快速排序是原地排序，不需要辅助数组，但是递归调用需要辅助栈。</p>
<p>快速排序最好的情况下是每次都正好能将数组对半分，这样递归调用次数才是最少的。这种情况下比较次数为 CN=2CN/2+N，复杂度为 O(NlogN)。</p>
<p>最坏的情况下，第一次从最小的元素切分，第二次从第二小的元素切分，如此这般。因此最坏的情况下需要比较 N2/2。为了防止数组最开始就是有序的，在进行快速排序时需要随机打乱数组。</p>
<h4 id="2-双路快速排序"><a href="#2-双路快速排序" class="headerlink" title="2. 双路快速排序"></a>2. 双路快速排序</h4><p>若果数组中含有大量重复的元素，则partition很可能把数组划分成两个及其不平衡的两部分，时间复杂度退化成O(n²)。这时候应该把小于v和大于v放在数组两端。</p>
<p><img src="http://r.photo.store.qq.com/psb?/932c31e8-a24c-44e8-b0eb-07a959965080/qOx3ZGM.Q7rctahPmjDSgEtPW9ElmIUxwjcdSmHQpV4!/r/dFIBAAAAAAAA" alt="双路快排"></p>
<figure class="highlight java hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">// 双路快速排序的partition</span></span><br><span class="line"><span class="hljs-comment">// 返回p, 使得arr[l...p-1] &lt; arr[p] ; arr[p+1...r] &gt; arr[p]</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 随机在arr[l...r]的范围中, 选择一个数值作为标定点pivot</span></span><br><span class="line">    <span class="hljs-comment">// swap(arr, l, (int) (Math.random() % (r - l + 1)) + l);</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">int</span> v = arr[l];</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// arr[l+1...i) &lt;= v; arr(j...r] &gt;= v</span></span><br><span class="line">    <span class="hljs-keyword">int</span> i = l + <span class="hljs-number">1</span>, j = r;</span><br><span class="line">    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;</span><br><span class="line">        <span class="hljs-comment">// 注意这里的边界, arr[i].compareTo(v) &lt; 0, 不能是arr[i].compareTo(v) &lt;= 0</span></span><br><span class="line">        <span class="hljs-comment">// 思考一下为什么?</span></span><br><span class="line">        <span class="hljs-keyword">while</span> (i &lt;= r &amp;&amp; arr[i] &lt; v)</span><br><span class="line">            i++;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">// 注意这里的边界, arr[j].compareTo(v) &gt; 0, 不能是arr[j].compareTo(v) &gt;= 0</span></span><br><span class="line">        <span class="hljs-comment">// 思考一下为什么?</span></span><br><span class="line">        <span class="hljs-keyword">while</span> (j &gt;= l + <span class="hljs-number">1</span> &amp;&amp; arr[j] &gt; v)</span><br><span class="line">            j--;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">// 对于上面的两个边界的设定, 有的同学在课程的问答区有很好的回答:)</span></span><br><span class="line">        <span class="hljs-comment">// 大家可以参考: http://coding.imooc.com/learn/questiondetail/4920.html</span></span><br><span class="line">        <span class="hljs-keyword">if</span> (i &gt; j)</span><br><span class="line">            <span class="hljs-keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        swap(arr, i, j);</span><br><span class="line">        i++;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    swap(arr, l, j);</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 递归使用快速排序,对arr[l...r]的范围进行排序</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">QuickSort2Ways</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">// 对于小规模数组, 使用插入排序</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;</span><br><span class="line">    <span class="hljs-keyword">int</span> p = partition(arr, l, r);</span><br><span class="line">    QuickSort2Ways(arr, l, p - <span class="hljs-number">1</span>);</span><br><span class="line">    QuickSort2Ways(arr, p + <span class="hljs-number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-三路快速排序"><a href="#3-三路快速排序" class="headerlink" title="3. 三路快速排序"></a>3. 三路快速排序</h4><p>数组分成三个部分，大于v 等于v 小于v</p>
<p>在具有大量重复键值对的情况下使用三路快排</p>
<p><img src="http://r.photo.store.qq.com/psb?/932c31e8-a24c-44e8-b0eb-07a959965080/yVHsV635.YSKc8pNUwGU*kbQTlj.MyOwIl5ihuAjKL4!/r/dFIBAAAAAAAA" alt="三路快排"></p>
<figure class="highlight java hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">// 递归使用快速排序,对arr[l...r]的范围进行排序</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">QuickSort3Ways</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 随机在arr[l...r]的范围中, 选择一个数值作为标定点pivot</span></span><br><span class="line">    swap( arr, l, (<span class="hljs-keyword">int</span>)(Math.random()*(r-l+<span class="hljs-number">1</span>)) + l );</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">int</span> v = arr[l];</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">int</span> lt = l;     <span class="hljs-comment">// arr[l+1...lt] &lt; v</span></span><br><span class="line">    <span class="hljs-keyword">int</span> gt = r + <span class="hljs-number">1</span>; <span class="hljs-comment">// arr[gt...r] &gt; v</span></span><br><span class="line">    <span class="hljs-keyword">int</span> i = l+<span class="hljs-number">1</span>;    <span class="hljs-comment">// arr[lt+1...i) == v</span></span><br><span class="line">    <span class="hljs-keyword">while</span>( i &lt; gt )&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span>( arr[i] &lt; v)&#123;</span><br><span class="line">            swap( arr, i, lt+<span class="hljs-number">1</span>);</span><br><span class="line">            i ++;</span><br><span class="line">            lt ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( arr[i] &gt; v )&#123;</span><br><span class="line">            swap( arr, i, gt-<span class="hljs-number">1</span>);</span><br><span class="line">            gt --;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">// arr[i] == v</span></span><br><span class="line">            i ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap( arr, l, lt );</span><br><span class="line"></span><br><span class="line">    QuickSort3Ways(arr, l, lt-<span class="hljs-number">1</span>);</span><br><span class="line">    QuickSort3Ways(arr, gt, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="堆排序（Heap-Sort）"><a href="#堆排序（Heap-Sort）" class="headerlink" title="堆排序（Heap Sort）"></a>堆排序（Heap Sort）</h3><h4 id="1-堆"><a href="#1-堆" class="headerlink" title="1. 堆"></a>1. 堆</h4><p>堆的某个节点的值总是大于等于子节点的值，并且堆是一颗完全二叉树。</p>
<p>堆可以用数组来表示，因为堆是完全二叉树，而完全二叉树很容易就存储在数组中。位置 k 的节点的父节点位置为 k/2，而它的两个子节点的位置分别为 2k 和 2k+1。这里不使用数组索引为 0 的位置，是为了更清晰地描述节点的位置关系。</p>
<p><img src="http://r.photo.store.qq.com/psb?/932c31e8-a24c-44e8-b0eb-07a959965080/SJnsOdMESxzcanQb5Zff9m1PWcvETjWcZqUhzOG8LrY!/r/dDQBAAAAAAAA" alt="堆"></p>
<h4 id="2-上浮和下沉"><a href="#2-上浮和下沉" class="headerlink" title="2. 上浮和下沉"></a>2. 上浮和下沉</h4><p>在堆中，当一个节点比父节点大，那么需要交换这个两个节点。交换后还可能比它新的父节点大，因此需要不断地进行比较和交换操作，把这种操作称为<strong>上浮（ShiftUp）</strong>。</p>
<p><img src="http://r.photo.store.qq.com/psb?/932c31e8-a24c-44e8-b0eb-07a959965080/P1R6qKYyIG2cvmg4iwq311KwKxl3kHHtkQASAay.YyQ!/r/dFIBAAAAAAAA" alt="上浮"> </p>
<figure class="highlight java hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shiftUp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">while</span>( k &gt; <span class="hljs-number">1</span> &amp;&amp; data[k/<span class="hljs-number">2</span>] &lt; data[k]))&#123;</span><br><span class="line">        swap(k, k/<span class="hljs-number">2</span>);</span><br><span class="line">        k /= <span class="hljs-number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似地，当一个节点比子节点来得小，也需要不断地向下进行比较和交换操作，把这种操作称为<strong>下沉（Shift Down）</strong>。一个节点如果有两个子节点，应当与两个子节点中最大那么节点进行交换。</p>
<p><img src="http://r.photo.store.qq.com/psb?/932c31e8-a24c-44e8-b0eb-07a959965080/Q2F4.olX0m5xGkcelT5Zl7kkA62Qv9sWv.oIAEKKf7E!/r/dDYBAAAAAAAA" alt="下沉"> </p>
<figure class="highlight java hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shiftDown</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">while</span>( <span class="hljs-number">2</span>*k &lt;= count )&#123; <span class="hljs-comment">// 当前结点有左孩子</span></span><br><span class="line">        <span class="hljs-keyword">int</span> j = <span class="hljs-number">2</span>*k; <span class="hljs-comment">// 在此轮循环中,data[k]和data[j]交换位置</span></span><br><span class="line">        <span class="hljs-keyword">if</span>( j+<span class="hljs-number">1</span> &lt;= count &amp;&amp; data[j+<span class="hljs-number">1</span>] &gt; data[j] )</span><br><span class="line">            j ++;</span><br><span class="line">        <span class="hljs-comment">// data[j] 是 data[2*k]和data[2*k+1]中的最大值</span></span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">if</span>( data[k] &gt;= data[j] ) </span><br><span class="line">            <span class="hljs-keyword">break</span>;</span><br><span class="line">        swap(k, j);</span><br><span class="line">        k = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-插入元素"><a href="#3-插入元素" class="headerlink" title="3.插入元素"></a>3.插入元素</h4><p>将新元素放到数组末尾，然后上浮到合适的位置。  </p>
<figure class="highlight java hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">// 向最大堆中插入一个新的元素 item</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(Item item)</span></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">assert</span> count + <span class="hljs-number">1</span> &lt;= capacity;</span><br><span class="line">    data[count+<span class="hljs-number">1</span>] = item;</span><br><span class="line">    count ++;</span><br><span class="line">    shiftUp(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-删除最大元素"><a href="#4-删除最大元素" class="headerlink" title="4. 删除最大元素"></a>4. 删除最大元素</h4><figure class="highlight java hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">// 从最大堆中取出堆顶元素, 即堆中所存储的最大数据</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Item <span class="hljs-title">extractMax</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">assert</span> count &gt; <span class="hljs-number">0</span>;</span><br><span class="line">    Item ret = data[<span class="hljs-number">1</span>];</span><br><span class="line">    </span><br><span class="line">    swap( <span class="hljs-number">1</span> , count );</span><br><span class="line">    count --;</span><br><span class="line">    shiftDown(<span class="hljs-number">1</span>);</span><br><span class="line">    <span class="hljs-keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-堆排序"><a href="#5-堆排序" class="headerlink" title="5. 堆排序"></a>5. 堆排序</h4><p>由于堆可以很容易得到最大的元素并删除它，不断地进行这种操作可以得到一个递减序列。如果把最大元素和当前堆中数组的最后一个元素交换位置，并且不删除它，那么就可以得到一个从尾到头的递减序列，从正向来看就是一个递增序列。因此很容易使用堆来进行排序。并且堆排序是原地排序，不占用额外空间。</p>
<figure class="highlight java hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">// 不使用一个额外的最大堆, 直接在原数组上进行原地的堆排序</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeapSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 对整个arr数组使用HeapSort1排序</span></span><br><span class="line">    <span class="hljs-comment">// HeapSort1, 将所有的元素依次添加到堆中, 在将所有元素从堆中依次取出来, 即完成了排序</span></span><br><span class="line">    <span class="hljs-comment">// 无论是创建堆的过程, 还是从堆中依次取出元素的过程, 时间复杂度均为O(nlogn)</span></span><br><span class="line">    <span class="hljs-comment">// 整个堆排序的整体时间复杂度为O(nlogn)</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort1</span><span class="hljs-params">(Comparable[] arr)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">int</span> n = arr.length;</span><br><span class="line">        MaxHeap&lt;Comparable&gt; maxHeap = <span class="hljs-keyword">new</span> MaxHeap&lt;Comparable&gt;(n);</span><br><span class="line">        <span class="hljs-keyword">for</span>( <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i ++ )</span><br><span class="line">            maxHeap.insert(arr[i]);</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">for</span>( <span class="hljs-keyword">int</span> i = n-<span class="hljs-number">1</span> ; i &gt;= <span class="hljs-number">0</span> ; i -- )</span><br><span class="line">            arr[i] = maxHeap.extractMax();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 只通过shiftDown操作进行排序</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort2</span><span class="hljs-params">(Comparable[] arr)</span></span>&#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> n = arr.length;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">// 注意，此时我们的堆是从0开始索引的</span></span><br><span class="line">        <span class="hljs-comment">// 从(最后一个元素的索引-1)/2开始</span></span><br><span class="line">        <span class="hljs-comment">// 最后一个元素的索引 = n-1</span></span><br><span class="line">        <span class="hljs-keyword">for</span>( <span class="hljs-keyword">int</span> i = (n-<span class="hljs-number">1</span>-<span class="hljs-number">1</span>)/<span class="hljs-number">2</span> ; i &gt;= <span class="hljs-number">0</span> ; i -- )</span><br><span class="line">            shiftDown2(arr, n, i);</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">for</span>( <span class="hljs-keyword">int</span> i = n-<span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span> ; i-- )&#123; <span class="hljs-comment">// 这个的目的是让序列从小到大排序</span></span><br><span class="line">            swap( arr, <span class="hljs-number">0</span>, i);</span><br><span class="line">            shiftDown2(arr, i, <span class="hljs-number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 交换堆中索引为i和j的两个元素</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(Object[] arr, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        Object t = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 原始的shiftDown过程</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shiftDown</span><span class="hljs-params">(Comparable[] arr, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="hljs-keyword">while</span>( <span class="hljs-number">2</span>*k+<span class="hljs-number">1</span> &lt; n )&#123;</span><br><span class="line">            <span class="hljs-keyword">int</span> j = <span class="hljs-number">2</span>*k+<span class="hljs-number">1</span>;</span><br><span class="line">            <span class="hljs-keyword">if</span>( j+<span class="hljs-number">1</span> &lt; n &amp;&amp; arr[j+<span class="hljs-number">1</span>].compareTo(arr[j]) &gt; <span class="hljs-number">0</span> )</span><br><span class="line">                j += <span class="hljs-number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">if</span>( arr[k].compareTo(arr[j]) &gt;= <span class="hljs-number">0</span> )<span class="hljs-keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            swap( arr, k, j);</span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 优化的shiftDown过程, 使用赋值的方式取代不断的swap,</span></span><br><span class="line">    <span class="hljs-comment">// 该优化思想和我们之前对插入排序进行优化的思路是一致的</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shiftDown2</span><span class="hljs-params">(Comparable[] arr, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Comparable e = arr[k];</span><br><span class="line">        <span class="hljs-keyword">while</span>( <span class="hljs-number">2</span>*k+<span class="hljs-number">1</span> &lt; n )&#123;</span><br><span class="line">            <span class="hljs-keyword">int</span> j = <span class="hljs-number">2</span>*k+<span class="hljs-number">1</span>;</span><br><span class="line">            <span class="hljs-keyword">if</span>( j+<span class="hljs-number">1</span> &lt; n &amp;&amp; arr[j+<span class="hljs-number">1</span>].compareTo(arr[j]) &gt; <span class="hljs-number">0</span> )</span><br><span class="line">                j += <span class="hljs-number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">if</span>( e.compareTo(arr[j]) &gt;= <span class="hljs-number">0</span> )</span><br><span class="line">                <span class="hljs-keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            arr[k] = arr[j];</span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        arr[k] = e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 测试 HeapSort</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer[] arr = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">91</span>, <span class="hljs-number">8</span>, <span class="hljs-number">7</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>&#125;;</span><br><span class="line">        HeapSort.sort2(arr);</span><br><span class="line">        PrintHelper.printArray(arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-堆排序的应用——Top-K问题"><a href="#6-堆排序的应用——Top-K问题" class="headerlink" title="6. 堆排序的应用——Top K问题"></a>6. 堆排序的应用——Top K问题</h4><p>例如，有1亿个浮点数，如何找出其中最大的10000个？</p>
<h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><p><strong>算法描述</strong><br>1.计数排序是一种非常快捷的稳定性强的排序方法，时间复杂度O(n+k),其中n为要排序的数的个数，k为要排序的数的组大值。计数排序对一定量的整数排序时候的速度非常快，一般快于其他排序算法。但计数排序局限性比较大，只限于对整数进行排序。计数排序是消耗空间发杂度来获取快捷的排序方法，其空间发展度为O（K）同理K为要排序的最大值。</p>
<p>2.计数排序的基本思想为一组数在排序之前先统计这组数中其他数小于这个数的个数，则可以确定这个数的位置。例如要排序的数为 7 4 2 1 5 3 1 5；则比7小的有7个数，所有7应该在排序好的数列的第八位，同理3在第四位，对于重复的数字，1在1位和2位（暂且认为第一个1比第二个1小），5和1一样位于6位和7位。</p>
<p>3.计数排序的实现办法：</p>
<p>　　首先需要三个数组，第一个数组记录A要排序的数列大小为n，第二个数组B要记录比某个数小的其他数字的个数所以第二个数组的大小应当为K（数列中最大数的大小），第三个数组C为记录排序好了的数列的数组，大小应当为n。</p>
<p>　　接着需要确定数组最大值并确定B数组的大小。并对每个数由小到大的记录数列中每个数的出现次数。因为是有小到大通过出现次数可以通过前面的所有数的出现次数来确定比这个数小的数的个数，从而确定其位置。</p>
<p>　　对于重复的数，每排好一个数则对其位置数进行减减操作，以此对完成其余相同的数字进行排位。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight c hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> n;</span><br><span class="line">    <span class="hljs-built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="hljs-keyword">int</span> *a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];</span><br><span class="line">    <span class="hljs-keyword">int</span> *c = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];</span><br><span class="line">    <span class="hljs-built_in">memset</span>(a, <span class="hljs-number">0</span>, n*<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));</span><br><span class="line">    <span class="hljs-built_in">memset</span>(c, <span class="hljs-number">0</span>, n*<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));</span><br><span class="line">    <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="hljs-built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">        max = a[i]&gt;max ? a[i] : max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">int</span> *b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[max+<span class="hljs-number">1</span>];</span><br><span class="line">    <span class="hljs-built_in">memset</span>(b, <span class="hljs-number">0</span>, (max+<span class="hljs-number">1</span>)*<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        b[a[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; max + <span class="hljs-number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        b[i] = b[i] + b[i - <span class="hljs-number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        b[a[i]]--;</span><br><span class="line">        c[b[a[i]]] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="hljs-built_in">cout</span> &lt;&lt; c[i] &lt;&lt; <span class="hljs-built_in">endl</span>;</span><br><span class="line">    <span class="hljs-keyword">delete</span>[]a;</span><br><span class="line">    <span class="hljs-keyword">delete</span>[]b;</span><br><span class="line">    <span class="hljs-keyword">delete</span>[]c;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果:</p>
<p>10<br>2 1 3 4 2 5 6 1 8 11<br>1<br>1<br>2<br>2<br>3<br>4<br>5<br>6<br>8<br>11<br>请按任意键继续. . .</p>
<p>这就是传说中的时间复杂度只有O（n）的排序算法；</p>
<h3 id="排序算法总结"><a href="#排序算法总结" class="headerlink" title="排序算法总结"></a>排序算法总结</h3><table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">平均时间复杂度</th>
<th style="text-align:center">原地排序</th>
<th style="text-align:center">额外空间</th>
<th style="text-align:center">稳定排序</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">插入排序</td>
<td style="text-align:center">O(n^2)</td>
<td style="text-align:center">√</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td style="text-align:center">归并排序</td>
<td style="text-align:center">O(nlogn)</td>
<td style="text-align:center">×</td>
<td style="text-align:center">O(n)</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td style="text-align:center">快速排序</td>
<td style="text-align:center">O(nlogn)</td>
<td style="text-align:center">√</td>
<td style="text-align:center">O(logn)</td>
<td style="text-align:center">×</td>
</tr>
<tr>
<td style="text-align:center">堆排序</td>
<td style="text-align:center">O(nlogn)</td>
<td style="text-align:center">√</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">×</td>
</tr>
</tbody>
</table>
<p>稳定排序：对于相等的元素，在排序后，原来靠前的元素依然靠前。相等元素的相对位置没有发生变化。</p>
<figure class="highlight java hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">// 可以通过⾃自定义⽐比较函数，让排序算法不不存在稳定性的问题。</span></span><br><span class="line">bool operator&lt;(<span class="hljs-keyword">const</span> Student&amp; otherStudent)&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> score != otherStudent.score ?</span><br><span class="line">    score &gt; otherStudent.score :</span><br><span class="line">    name &lt; otherStudent.name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://www.cnblogs.com/onepixel/articles/7674659.html" target="_blank" rel="noopener">十大经典排序算法（动图演示）</a></p>

    
    </div>
    
    <div class="columns is-variable is-1 is-multiline is-mobile">
    
        <span class="column is-narrow"><a class="tag is-light article-tag" href="/tags/面试题/">#面试题</a></span>
    
        <span class="column is-narrow"><a class="tag is-light article-tag" href="/tags/算法/">#算法</a></span>
    
    </div>
    
    
    <div class="columns is-mobile is-multiline article-nav">
        <span class="column is-12-mobile is-half-desktop  article-nav-prev">
            
            <a href="/2018/09/12/Java常见的设计模式/">Java常见的设计模式</a>
            
        </span>
        <span class="column is-12-mobile is-half-desktop is-hidden-mobile article-nav-next">
            
        </span>
    </div>
    
</article>




    </div>
</section>
    <footer class="footer">
    <div class="container">
        <div class="columns content">
            <div class="column is-narrow has-text-centered">
                &copy; 2019 lsb&nbsp;
                Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> & <a
                        href="http://github.com/ppoffice/hexo-theme-minos">Minos</a>
            </div>
            <div class="column is-hidden-mobile"></div>

            
            <div class="column is-narrow">
                <div class="columns is-mobile is-multiline is-centered">
                
                    
                <a class="column is-narrow has-text-black" title="GitHub" href="https://github.com/imnice">
                    
                    GitHub
                    
                </a>
                
                </div>
            </div>
            
            
        </div>
    </div>
</footer>
    <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script>

<!-- test if the browser is outdated -->
<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.js"></script>
<script>
    $(document).ready(function () {
        // plugin function, place inside DOM ready function
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        })
    });
</script>

<script>
    window.FontAwesomeConfig = {
        searchPseudoElements: true
    }
    moment.locale("zh-CN");
</script>


    
    
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script>
    MathJax.Hub.Config({
        "HTML-CSS": {matchFontHeight: false},
        SVG: {matchFontHeight: false},
        CommonHTML: {matchFontHeight: false}
    });
</script>

    
    
    
    
<script src="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/js/lightgallery-all.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/js/jquery.justifiedGallery.min.js"></script>
<script>
    (function ($) {
        $(document).ready(function () {
            if (typeof($.fn.lightGallery) === 'function') {
                $('.article.gallery').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof($.fn.justifiedGallery) === 'function') {
                $('.justified-gallery').justifiedGallery();
            }
        });
    })(jQuery);
</script>

    
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script>
    <style>
        .hljs {
            position: relative;
        }

        .hljs .clipboard-btn {
            float: right;
            color: #9a9a9a;
            background: none;
            border: none;
        }

        .hljs > .clipboard-btn {
            display: none;
            position: absolute;
            right: 4px;
            top: 4px;
        }

        .hljs:hover > .clipboard-btn {
            display: inline;
        }

        .hljs > figcaption > .clipboard-btn {
            margin-right: 4px;
        }
    </style>
    <script>
      $(document).ready(function () {
        $('figure.hljs').each(function(i, figure) {
          var codeId = 'code-' + i;
          var code = figure.querySelector('.code');
          var copyButton = $('<button>Copy <i class="far fa-clipboard"></i></button>');
          code.id = codeId;
          copyButton.addClass('clipboard-btn');
          copyButton.attr('data-clipboard-target-id', codeId);

          var figcaption = figure.querySelector('figcaption');

          if (figcaption) {
            figcaption.append(copyButton[0]);
          } else {
            figure.prepend(copyButton[0]);
          }
        })

        var clipboard = new ClipboardJS('.clipboard-btn', {
          target: function(trigger) {
            return document.getElementById(trigger.getAttribute('data-clipboard-target-id'));
          }
        });
      })
    </script>

    
    

    


<script src="/js/script.js"></script>

    
    <div class="searchbox ins-search">
    <div class="searchbox-mask"></div>
    <div class="searchbox-container ins-search-container">
        <div class="searchbox-input-wrapper">
            <input type="text" class="searchbox-input ins-search-input" placeholder="站内搜索" />
            <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="searchbox-result-wrapper ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: '文章',
                PAGES: '页面',
                CATEGORIES: '分类',
                TAGS: '标签',
                UNTITLED: '(无标题)',
            },
            CONTENT_URL: '/content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>
<script src="/js/insight.js"></script>
    
</body>
</html>