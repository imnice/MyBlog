<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Java集合框架小结   如：12345678 右移2位  78123456"><meta name="keywords" content="Java基础"><meta name="author" content="LSB - imdangerous@163.com,undefined"><meta name="copyright" content="LSB - imdangerous@163.com"><title>Java集合框架小结 | LSB.pro</title><link rel="shortcut icon" href="/myicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.5.6"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.5.6"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector、ArrayList和LinkedList的比较"><span class="toc-number">1.</span> <span class="toc-text">Vector、ArrayList和LinkedList的比较</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayList-与-LinkedList"><span class="toc-number">1.1.</span> <span class="toc-text">ArrayList 与 LinkedList</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#synchronizedList封装ArrayList（LinkedList）得到线程安全的List"><span class="toc-number">1.2.</span> <span class="toc-text">synchronizedList封装ArrayList（LinkedList）得到线程安全的List</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap浅析"><span class="toc-number">2.</span> <span class="toc-text">HashMap浅析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#数据存储结构"><span class="toc-number">2.1.</span> <span class="toc-text">数据存储结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#重要参数"><span class="toc-number">2.2.</span> <span class="toc-text">重要参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap的put方法"><span class="toc-number">2.3.</span> <span class="toc-text">HashMap的put方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap与HashTable"><span class="toc-number">2.4.</span> <span class="toc-text">HashMap与HashTable</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#什么是-fail-fast-机制"><span class="toc-number">2.5.</span> <span class="toc-text">什么是 fail-fast 机制?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#小结"><span class="toc-number">2.6.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ConcurrentHashMap浅析"><span class="toc-number">3.</span> <span class="toc-text">ConcurrentHashMap浅析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#存储结构"><span class="toc-number">3.1.</span> <span class="toc-text">存储结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#size-操作"><span class="toc-number">3.2.</span> <span class="toc-text">size 操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#同步方式"><span class="toc-number">3.3.</span> <span class="toc-text">同步方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK-1-8-的改动"><span class="toc-number">3.4.</span> <span class="toc-text">JDK 1.8 的改动</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashSet"><span class="toc-number">4.</span> <span class="toc-text">HashSet</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#成员变量"><span class="toc-number">4.1.</span> <span class="toc-text">成员变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#构造函数"><span class="toc-number">4.2.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#add"><span class="toc-number">4.3.</span> <span class="toc-text">add()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LinkedHashMap经典用法"><span class="toc-number">5.</span> <span class="toc-text">LinkedHashMap经典用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#容器中的设计模式"><span class="toc-number">6.</span> <span class="toc-text">容器中的设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#迭代器模式"><span class="toc-number">6.1.</span> <span class="toc-text">迭代器模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#适配器模式"><span class="toc-number">6.2.</span> <span class="toc-text">适配器模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面试指南"><span class="toc-number">7.</span> <span class="toc-text">面试指南</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-ArrayList和LinkedList区别"><span class="toc-number">7.1.</span> <span class="toc-text">1. ArrayList和LinkedList区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-HashMap和HashTable区别，HashMap的key类型"><span class="toc-number">7.2.</span> <span class="toc-text">2. HashMap和HashTable区别，HashMap的key类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-HashMap和ConcurrentHashMap"><span class="toc-number">7.3.</span> <span class="toc-text">3. HashMap和ConcurrentHashMap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Hashtable的原理"><span class="toc-number">7.4.</span> <span class="toc-text">4. Hashtable的原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-Hash冲突的解决办法"><span class="toc-number">7.5.</span> <span class="toc-text">5. Hash冲突的解决办法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-什么是迭代器"><span class="toc-number">7.6.</span> <span class="toc-text">6. 什么是迭代器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-构造相同hash的字符串进行攻击，这种情况应该怎么处理？JDK7如何处理"><span class="toc-number">7.7.</span> <span class="toc-text">7. 构造相同hash的字符串进行攻击，这种情况应该怎么处理？JDK7如何处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-Hashmap为什么大小是2的幂次"><span class="toc-number">7.8.</span> <span class="toc-text">8. Hashmap为什么大小是2的幂次</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="http://r.photo.store.qq.com/psb?/1dbb9f7e-a947-470f-9051-8b79e39c489a/stGwyjKcMBnywN.U5oDVxhfR8PuH2eEtmqs*eKZTAt8!/r/dDUBAAAAAAAA"></div><div class="author-info__name text-center">LSB - imdangerous@163.com</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">13</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">6</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">1</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(http://r.photo.store.qq.com/psb?/1dbb9f7e-a947-470f-9051-8b79e39c489a/ozxzWw8ZnzjRh85fDv0oiIesbtA7gP5ya6psIRpynkk!/r/dDQBAAAAAAAA)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">LSB.pro</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/about">About</a></span></div><div id="post-info"><div id="post-title">Java集合框架小结</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-09-22</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/默认分类/">默认分类</a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">8.7k</span><span class="post-meta__separator">|</span><span>Reading time: 29 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>Java集合框架小结</p>
<a id="more"></a>
<p><img src="http://r.photo.store.qq.com/psb?/932c31e8-a24c-44e8-b0eb-07a959965080/Zok**qYH9ruKdeJvc7MbFVvwm4wYpnvArjdbQo9aT0I!/r/dEYBAAAAAAAA" alt="Java集合框架图"></p>
<h3 id="Vector、ArrayList和LinkedList的比较"><a href="#Vector、ArrayList和LinkedList的比较" class="headerlink" title="Vector、ArrayList和LinkedList的比较"></a>Vector、ArrayList和LinkedList的比较</h3><table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">Vector</th>
<th style="text-align:center">ArrayList</th>
<th style="text-align:center">LinkedList</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">底层结构</td>
<td style="text-align:center">数组</td>
<td style="text-align:center">数组</td>
<td style="text-align:center">双向链表</td>
</tr>
<tr>
<td style="text-align:center">插/查速度</td>
<td style="text-align:center">查询快，插入慢</td>
<td style="text-align:center">查询快，插入慢</td>
<td style="text-align:center">查询慢，插入快</td>
</tr>
<tr>
<td style="text-align:center">初始化默认容量</td>
<td style="text-align:center">10（每次扩容一倍）</td>
<td style="text-align:center">10（每次扩容1.5倍）</td>
<td style="text-align:center">——</td>
</tr>
<tr>
<td style="text-align:center">是否线程安全</td>
<td style="text-align:center">是</td>
<td style="text-align:center">否</td>
<td style="text-align:center">否</td>
</tr>
</tbody>
</table>
<p><code>ArrayList</code>：线程不同步。默认初始容量为 10，当数组大小不足时容量扩大为 1.5 倍。为追求效率，ArrayList 没有实现同步（synchronized），如果需要多个线程并发访问，用户可以手动同步，也可使用 Vector 替代。 (注意：List<string> list = new ArrayList<string>(20);这条语句list不会扩容，直接创建了一个20容量的list )<br><strong>删除元素</strong>：需要调用 System.arraycopy() 将 index+1 后面的元素都复制到 index 位置上。<br><strong>扩容：</strong>添加元素时使用 ensureCapacityInternal() 方法来保证容量足够，如果不够时，需要使用 grow() 方法进行扩容，新容量的大小为 <code>oldCapacity + (oldCapacity &gt;&gt; 1)</code>，也就是旧容量的 1.5 倍。扩容操作需要调用 <code>Arrays.copyOf()</code> 把原数组整个复制到新数组中，这个操作代价很高，因此最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数。</string></string></p>
<p><code>LinkedList</code>：线程不同步。<strong>双向链接实现</strong>。LinkedList 同时实现了 List 接口和 Deque 接口，也就是说它既可以看作一个顺序容器，又可以看作一个队列（Queue），同时又可以看作一个栈（Stack）。这样看来，LinkedList 简直就是个全能冠军。当你需要使用栈或者队列时，可以考虑使用 LinkedList，一方面是因为 Java 官方已经声明不建议使用 Stack 类，更遗憾的是，Java 里根本没有一个叫做 Queue 的类（它是个接口名字）。关于栈或队列，现在的首选是 ArrayDeque，它有着比 LinkedList（当作栈或队列使用时）有着更好的性能。 </p>
<h4 id="ArrayList-与-LinkedList"><a href="#ArrayList-与-LinkedList" class="headerlink" title="ArrayList 与 LinkedList"></a>ArrayList 与 LinkedList</h4><ul>
<li>ArrayList 基于动态数组实现，LinkedList 基于双向链表实现；</li>
<li>ArrayList 支持随机访问，LinkedList 不支持；</li>
<li><p>LinkedList 在任意位置添加删除元素更快。</p>
<p><code>Stack and Queue</code>：Java 里有一个叫做 Stack 的类，却没有叫做 Queue 的类（它是个接口名字）。当需要使用栈时，Java 已不推荐使用 Stack，而是推荐使用更高效的 ArrayDeque；既然 Queue 只是一个接口，当需要使用队列时也就首选 ArrayDeque 了（次选是 LinkedList ）。 </p>
</li>
</ul>
<p><code>Vector</code>：<strong>线程同步</strong>。默认初始容量为 10，当数组大小不足时容量扩大为 2 倍。它的同步是通过 <code>Iterator</code> 方法加 <code>synchronized</code> 实现的。</p>
<h4 id="synchronizedList封装ArrayList（LinkedList）得到线程安全的List"><a href="#synchronizedList封装ArrayList（LinkedList）得到线程安全的List" class="headerlink" title="synchronizedList封装ArrayList（LinkedList）得到线程安全的List"></a>synchronizedList封装ArrayList（LinkedList）得到线程安全的List</h4><p>为了获得线程安全的 ArrayList，可以使用  <code>Collections.synchronizedList();</code>  得到一个线程安全的  ArrayList。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;String&gt; synList = Collections.synchronizedList(list);</span><br></pre></td></tr></table></figure></p>
<p> <code>Stack</code>：<strong>线程同步</strong>。继承自 Vector，添加了几个方法来完成栈的功能。现在已经不推荐使用 Stack，在栈和队列中有限使用 ArrayDeque，其次是 LinkedList。</p>
<p><img src="http://r.photo.store.qq.com/psb?/932c31e8-a24c-44e8-b0eb-07a959965080/daAryZn4OBx.tezR2DldFP7oBvXLNe8o*c.49gG*H48!/r/dDEBAAAAAAAA" alt="集合机构图"></p>
<h3 id="HashMap浅析"><a href="#HashMap浅析" class="headerlink" title="HashMap浅析"></a><strong>HashMap浅析</strong></h3><h4 id="数据存储结构"><a href="#数据存储结构" class="headerlink" title="数据存储结构"></a>数据存储结构</h4><p>在 1.7 之前 JDK 采用「拉链法」来存储数据，即数组和链表结合的方式。<br>「拉链法」用专业点的名词来说叫做<strong>链地址法</strong>。简单来说，就是数组加链表的结合。在每个数组元素上存储的都是一个链表。<br>我们之前说到不同的 key 可能经过 hash 运算可能会得到相同的地址，但是一个数组单位上只能存放一个元素，采用链地址法以后，如果遇到相同的 hash 值的 key 的时候，我们可以将它放到作为数组元素的链表上。待我们去取元素的时候通过 hash 运算的结果找到这个链表，再在链表中找到与 key 相同的节点，就能找到 key 相应的值了。<br>JDK1.7 中新添加进来的元素总是放在数组相应的角标位置，而原来处于该角标的位置的节点作为 next 节点放到新节点的后边。<img src="http://r.photo.store.qq.com/psb?/932c31e8-a24c-44e8-b0eb-07a959965080/pYoXA.4eoJeFW*hdgi24opN2fdEWeqN0zaqlCLLMKrk!/r/dFMBAAAAAAAA" alt="HashMap存储结构"></p>
<p>JDK1.8 之后的 <code>HashMap</code> 底层在解决哈希冲突的时候，就不单单是使用数组加上单链表的组合了，因为当处理如果 hash 值冲突较多的情况下，链表的长度就会越来越长，此时通过单链表来寻找对应 Key 对应的 Value 的时候就会使得时间复杂度达到 O(n)，因此在 JDK1.8 之后，在链表新增节点导致链表长度超过 <code>TREEIFY_THRESHOLD = 8</code>  的时候，就会在添加元素的同时将原来的单链表转化为红黑树。<br>黑树是一种易于增删改查的二叉树，他对与数据的查询的时间复杂度是 <code>O(logn)</code> 级别，所以利用红黑树的特点就可以更高效的对 <code>HashMap</code> 中的元素进行操作。</p>
<p><strong>这里需要讲明白两个问题：数据底层具体存储的是什么？这样的存储方式有什么优点呢？</strong> </p>
<p>（1）从源码可知，HashMap 类中有一个非常重要的字段，就是 Node[] table，即哈希桶数组，明显它是一个 Node 的数组。我们来看 Node（ JDK1.8 中） 是何物。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;    <span class="comment">//用来定位数组索引位置</span></span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;   <span class="comment">//链表的下一个node</span></span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span></span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Node 是 HashMap 的一个内部类，实现了 Map.Entry 接口，本质是就是一个映射（键值对）。上图中的每个黑色圆点就是一个Node对象。</p>
<p>（2）HashMap 就是使用哈希表来存储的。哈希表为解决冲突，可以采用<strong>开放地址法</strong>和<strong>链地址法</strong>等来解决问题， Java 中 HashMap 采用了链地址法。链地址法，简单来说，就是数组加链表的结合。在每个数组元素上都一个链表结构，当数据被 Hash 后，得到数组下标，把数据放在对应下标元素的链表上。例如程序执行下面代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.put(<span class="string">"美团"</span>,<span class="string">"小美"</span>);</span><br></pre></td></tr></table></figure>
<p>系统将调用 “美团” 这个 key 的 hashCode() 方法得到其 hashCode 值（该方法适用于每个 Java 对象），然后再通过 Hash 算法的后两步运算（高位运算和取模运算，下文有介绍）来定位该键值对的存储位置，有时两个 key 会定位到相同的位置，表示发生了 Hash 碰撞。当然 Hash 算法计算结果越分散均匀，Hash 碰撞的概率就越小，map 的存取效率就会越高。</p>
<p>如果哈希桶数组很大，即使较差的 Hash 算法也会比较分散，如果哈希桶数组数组很小，即使好的 Hash 算法也会出现较多碰撞，所以就需要在空间成本和时间成本之间权衡，其实就是在根据实际情况确定哈希桶数组的大小，并在此基础上设计好的 hash 算法减少 Hash 碰撞。</p>
<p><strong>那么通过什么方式来控制 map 使得 Hash 碰撞的概率又小，哈希桶数组（Node[] table）占用空间又少呢？</strong></p>
<p>答案就是好的 Hash 算法和扩容机制。</p>
<p>在理解 Hash 和扩容流程之前，我们得先了解下 HashMap 的几个字段。从 HashMap 的默认构造函数源码可知，构造函数就是对下面几个字段进行初始化，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> threshold;             <span class="comment">// 所能容纳的key-value对极限 </span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;    <span class="comment">// 负载因子</span></span><br><span class="line"><span class="keyword">int</span> modCount;  </span><br><span class="line"><span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure>
<p>首先，<strong>Node[] table的初始化长度 length (默认值是16)</strong>，<strong>Load factor 为负载因子(默认值是0.75)</strong>，threshold 是 HashMap 所能容纳的最大数据量的 Node (键值对)个数。<strong>threshold = length * Load factor</strong>。也就是说，在数组定义好长度之后，负载因子越大，所能容纳的键值对个数越多。</p>
<p>结合负载因子的定义公式可知，threshold 就是在此 Load factor 和 length (数组长度)对应下允许的最大元素数目，超过这个数目就重新 resize(扩容)，扩容后的 HashMap 容量是之前容量的两倍。默认的负载因子 0.75 是对空间和时间效率的一个平衡选择，建议大家不要修改，除非在时间和空间比较特殊的情况下，如果内存空间很多而又对时间效率要求很高，可以降低负载因子 Load factor 的值；相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子 loadFactor 的值，这个值可以大于1。</p>
<p>size 这个字段其实很好理解，就是 HashMap 中实际存在的键值对数量。注意和 table 的长度 length、容纳最大键值对数量 threshold 的区别。而 modCount 字段主要用来记录 HashMap 内部结构发生变化的次数，主要用于迭代的快速失败。强调一点，内部结构发生变化指的是结构发生变化，例如 put 新键值对，但是某个 key 对应的 value 值被覆盖不属于结构变化。</p>
<p>在 HashMap 中，哈希桶数组 table 的长度 length 大小必须为$2^n$（一定是合数），这是一种非常规的设计，常规的设计是把桶的大小设计为素数。相对来说素数导致冲突的概率要小于合数，具体证明可以参考 <a href="https://blog.csdn.net/liuqiyao_01/article/details/14475159" target="_blank" rel="noopener">为什么一般hashtable的桶数会取一个素数？</a> ，<strong>Hashtable 初始化桶大小为 11，就是桶大小设计为素数的应用（Hashtable 扩容后不能保证还是素数）</strong>。HashMap 采用这种非常规设计，<strong>主要是为了在取模和扩容时做优化，同时为了减少冲突，HashMap 定位哈希桶索引位置时，也加入了高位参与运算的过程</strong>。</p>
<p>这里存在一个问题，即使负载因子和 Hash 算法设计的再合理，也免不了会出现拉链过长的情况，一旦出现拉链过长，则会严重影响 HashMap 的性能。于是，在 JDK1.8 版本中，对数据结构做了进一步的优化，引入了红黑树。而当链表长度太长（默认超过8）时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高 HashMap 的性能，其中会用到红黑树的插入、删除、查找等算法。本文不再对红黑树展开讨论，想了解更多红黑树数据结构的工作原理可以参考：<a href="https://blog.csdn.net/v_july_v/article/details/6105630" target="_blank" rel="noopener">教你初步了解红黑树</a>。</p>
<h4 id="重要参数"><a href="#重要参数" class="headerlink" title="重要参数"></a>重要参数</h4><table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">buckets</td>
<td style="text-align:center">在 HashMap 的注释里使用哈希桶来形象的表示数组中每个地址位置。注意这里并不是数组本身，数组是装哈希桶的，他可以被称为<strong>哈希表</strong>。</td>
</tr>
<tr>
<td style="text-align:center">capacity</td>
<td style="text-align:center">table 的容量大小，默认为 16。需要注意的是 capacity 必须保证为 2 的 n 次方。</td>
</tr>
<tr>
<td style="text-align:center">size</td>
<td style="text-align:center">table 的实际使用量。</td>
</tr>
<tr>
<td style="text-align:center">threshold</td>
<td style="text-align:center">size 的临界值，size 必须小于 threshold，如果大于等于，就必须进行扩容操作。</td>
</tr>
<tr>
<td style="text-align:center">loadFactor</td>
<td style="text-align:center">装载因子，table 能够使用的比例，threshold = capacity * loadFactor。</td>
</tr>
<tr>
<td style="text-align:center">TREEIFY_THRESHOLD</td>
<td style="text-align:center">树化阀值，哈希桶中的节点个数大于该值（默认为8）的时候将会被转为红黑树行存储结构。</td>
</tr>
<tr>
<td style="text-align:center">UNTREEIFY_THRESHOLD</td>
<td style="text-align:center">非树化阀值，小于该值（默认为 6）的时候将再次改为单链表的格式存储</td>
</tr>
</tbody>
</table>
<h4 id="HashMap的put方法"><a href="#HashMap的put方法" class="headerlink" title="HashMap的put方法"></a>HashMap的put方法</h4><p><img src="http://r.photo.store.qq.com/psb?/932c31e8-a24c-44e8-b0eb-07a959965080/OOReCP4mZlZFnQ.jd0EtCUsFnUe9WCSNplenB*5WLjU!/r/dFMBAAAAAAAA" alt="HashMap的put方法"></p>
<h4 id="HashMap与HashTable"><a href="#HashMap与HashTable" class="headerlink" title="HashMap与HashTable"></a>HashMap与HashTable</h4><ol>
<li>HashTable 使用 synchronized 来进行同步。</li>
<li>HashMap 可以插入键为 null 的 Entry。</li>
<li>HashMap 的迭代器是 fail-fast 迭代器。</li>
<li>HashMap 不能保证随着时间的推移 Map 中的元素次序是不变的。</li>
</ol>
<h4 id="什么是-fail-fast-机制"><a href="#什么是-fail-fast-机制" class="headerlink" title="什么是 fail-fast 机制?"></a>什么是 fail-fast 机制?</h4><p>fail-fast 机制在遍历一个集合时，当集合结构被修改，会抛出 Concurrent Modification Exception。</p>
<p>fail-fast 会在以下两种情况下抛出 Concurrent Modification Exception</p>
<p>（1）单线程环境</p>
<ul>
<li>集合被创建后，在遍历它的过程中修改了结构。</li>
<li>注意 remove() 方法会让 expectModcount 和 modcount 相等，所以是不会抛出这个异常。</li>
</ul>
<p>（2）多线程环境</p>
<ul>
<li>当一个线程在遍历这个集合，而另一个线程对这个集合的结构进行了修改。</li>
</ul>
<p>modCount 用来记录 ArrayList 结构发生变化的次数。结构发生变化是指<strong>添加</strong>或者<strong>删除</strong>至少一个元素的所有操作，或者是调整内部数组的大小，仅仅只是设置元素的值不算结构发生变化。</p>
<p>在进行序列化或者迭代等操作时，需要比较操作前后 modCount 是否改变，如果改变了需要抛出 Concurrent Modification Exception。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span> <span class="keyword">throws</span> java.io.IOException</span>&#123;</span><br><span class="line">    <span class="comment">// Write out element count, and any hidden stuff</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write out size as capacity for behavioural compatibility with clone()</span></span><br><span class="line">    s.writeInt(size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write out all elements in the proper order.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">        s.writeObject(elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ol>
<li>扩容是一个特别耗性能的操作，所以当程序员在使用 HashMap 的时候，估算 map 的大小，初始化的时候给一个大致的数值，避免 map 进行频繁的扩容。</li>
<li>负载因子是可以修改的，也可以大于1，但是建议不要轻易修改，除非情况非常特殊。</li>
<li>HashMap 是线程不安全的，不要在并发的环境中同时操作 HashMap，建议使用 ConcurrentHashMap。</li>
<li>JDK1.8 引入红黑树大程度优化了 HashMap 的性能。</li>
</ol>
<h3 id="ConcurrentHashMap浅析"><a href="#ConcurrentHashMap浅析" class="headerlink" title="ConcurrentHashMap浅析"></a>ConcurrentHashMap浅析</h3><p>哈希表是中非常高效，复杂度为 O(1) 的数据结构，在 Java 开发中，我们最常见到最频繁使用的就是 HashMap 和 HashTable，但是在线程竞争激烈的并发场景中使用都不够合理。</p>
<p>　　<strong>HashMap</strong> ：先说 HashMap，HashMap 是<strong>线程不安全</strong>的，在并发环境下，可能会形成<strong>环状链表</strong>（扩容时可能造成），导致 get 操作时，cpu 空转，所以，在并发环境中使 用HashMap 是非常危险的。</p>
<p>　　<strong>HashTable</strong> ： HashTable 和 HashMap的实现原理几乎一样，差别无非是：（1）HashTable不允许key和value为null；（2）HashTable是线程安全的。</p>
<p>　　但是 HashTable 线程安全的策略实现代价却太大了，简单粗暴，get/put 所有相关操作都是 synchronized 的，这相当于给整个哈希表加了一把大锁，多线程访问时候，只要有一个线程访问或操作该对象，那其他线程只能阻塞，相当于将所有的操作串行化，在竞争激烈的并发场景中性能就会非常差。</p>
<p>HashTable 性能差主要是由于所有操作需要竞争同一把锁，而如果容器中有多把锁，每一把锁锁一段数据，这样在多线程访问时不同段的数据时，就不会存在锁竞争了，这样便可以有效地提高并发效率。这就是ConcurrentHashMap 所采用的 “<strong>分段锁</strong>“ 思想。</p>
<p><img src="http://r.photo.store.qq.com/psb?/932c31e8-a24c-44e8-b0eb-07a959965080/q1If0xezU6uoj1mCzGxHPWZ3eL2xp.jbiLDWJWxuuwA!/r/dDQBAAAAAAAA" alt="ConcurrentHashMap分段锁思想"></p>
<h4 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h4><p>ConcurrentHashMap 采用了非常精妙的”分段锁”策略，ConcurrentHashMap 的主干是个 Segment 数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Segment&lt;K,V&gt;[] segments;</span><br></pre></td></tr></table></figure>
<p>　　Segment 继承了 ReentrantLock，所以它就是一种可重入锁（ReentrantLock)。在 ConcurrentHashMap，一个 Segment 就是一个子哈希表，Segment 里维护了一个 HashEntry 数组，并发环境下，对于不同 Segment 的数据进行操作是不用考虑锁竞争的。（就按默认的 ConcurrentLeve 为16来讲，理论上就允许 16 个线程并发执行，有木有很酷）</p>
<p>　　<strong>所以，对于同一个 Segment 的操作才需考虑线程同步，不同的 Segment 则无需考虑。</strong></p>
<p>Segment 类似于 HashMap，一个 Segment 维护着一个 HashEntry 数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure>
<p>HashEntry 是目前我们提到的最小的逻辑处理单元了。一个 ConcurrentHashMap 维护一个 Segment 数组，一个 Segment 维护一个 HashEntry 数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">volatile</span> V value;</span><br><span class="line">    <span class="keyword">volatile</span> HashEntry&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　ConcurrentHashMap 和 HashMap 实现上类似，最主要的差别是 ConcurrentHashMap 采用了分段锁（Segment），每个分段锁维护着几个桶（HashEntry），多个线程可以同时访问不同分段锁上的桶，从而使其并发度更高（并发度就是 Segment 的个数）。</p>
<p>Segment 继承自 <strong>ReentrantLock</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2249069246763182397L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SCAN_RETRIES =</span><br><span class="line">        Runtime.getRuntime().availableProcessors() &gt; <span class="number">1</span> ? <span class="number">64</span> : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Segment&lt;K,V&gt;[] segments;</span><br></pre></td></tr></table></figure>
<p>默认的并发级别为 16，也就是说默认创建 16 个 Segment。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;</span><br></pre></td></tr></table></figure>
<h4 id="size-操作"><a href="#size-操作" class="headerlink" title="size 操作"></a>size 操作</h4><p>每个 Segment 维护了一个 count 变量来统计该 Segment 中的键值对个数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The number of elements. Accessed only either within locks</span></span><br><span class="line"><span class="comment"> * or among other volatile reads that maintain visibility.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> count;</span><br></pre></td></tr></table></figure>
<p>在执行 size 操作时，需要遍历所有 Segment 然后把 count 累计起来。</p>
<p>ConcurrentHashMap 在执行 size 操作时先尝试不加锁，如果连续两次不加锁操作得到的结果一致，那么可以认为这个结果是正确的。</p>
<p>尝试次数使用 RETRIES_BEFORE_LOCK 定义，该值为 2，retries 初始值为 -1，因此尝试次数为 3。</p>
<p>如果尝试的次数超过 3 次，就需要对每个 Segment 加锁。</p>
<h4 id="同步方式"><a href="#同步方式" class="headerlink" title="同步方式"></a>同步方式</h4><p>Segment 继承自 ReentrantLock，所以我们可以很方便的对每一个 Segment 上锁。</p>
<p>对于读操作，获取 Key 所在的 Segment 时，需要保证可见性。具体实现上可以使用 volatile 关键字，也可使用锁。但使用锁开销太大，而使用 volatile 时每次写操作都会让所有 CPU 内缓存无效，也有一定开销。ConcurrentHashMap 使用如下方法保证可见性，取得最新的 Segment。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Segment&lt;K,V&gt; s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)</span><br></pre></td></tr></table></figure>
<p>获取 Segment 中的 HashEntry 时也使用了类似方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile</span><br><span class="line">  (tab, ((<span class="keyword">long</span>)(((tab.length - <span class="number">1</span>) &amp; h)) &lt;&lt; TSHIFT) + TBASE)</span><br></pre></td></tr></table></figure>
<p>对于写操作，并不要求同时获取所有 Segment 的锁，因为那样相当于锁住了整个 Map。它会先获取该 Key-Value 对所在的 Segment 的锁，获取成功后就可以像操作一个普通的 HashMap 一样操作该 Segment，并保证该Segment 的安全性。<br>同时由于其它 Segment 的锁并未被获取，因此理论上可支持 concurrencyLevel（等于 Segment 的个数）个线程安全的并发读写。</p>
<p>获取锁时，并不直接使用 lock 来获取，因为该方法获取锁失败时会挂起。事实上，它使用了自旋锁，如果 tryLock 获取锁失败，说明锁被其它线程占用，此时通过循环再次以 tryLock 的方式申请锁。如果在循环过程中该 Key 所对应的链表头被修改，则重置 retry 次数。如果 retry 次数超过一定值，则使用 lock 方法申请锁。</p>
<p>这里使用自旋锁是因为自旋锁的效率比较高，但是它消耗 CPU 资源比较多，因此在自旋次数超过阈值时切换为互斥锁。</p>
<h4 id="JDK-1-8-的改动"><a href="#JDK-1-8-的改动" class="headerlink" title="JDK 1.8 的改动"></a>JDK 1.8 的改动</h4><ul>
<li>JDK 1.7 使用分段锁机制来实现并发更新操作，核心类为 Segment，它继承自重入锁 ReentrantLock，并发程度与 Segment 数量相等。</li>
<li>JDK 1.8 使用了 CAS 操作来支持更高的并发度，在 CAS 操作失败时使用内置锁 synchronized。</li>
<li>并且 JDK 1.8 的实现也在链表过长时会转换为红黑树。</li>
</ul>
<h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>　　前面已经说过 HashSet 是对 HashMap 的简单包装，对 HashSet 的函数调用都会转换成合适的 HashMap 方法，因此 HashSet 的实现非常简单，只有不到 300 行代码（适配器模式）。这里不再赘述。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//HashSet是对HashMap的简单包装</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	......</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;<span class="comment">//HashSet里面有一个HashMap</span></span><br><span class="line">    <span class="comment">// Dummy value to associate with an Object in the backing Map</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;<span class="comment">//简单的方法转换</span></span><br><span class="line">        <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h4><p>首先了解下 <code>HashSet</code> 的成员变量:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dummy value to associate with an Object in the backing Map</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure>
<p>发现主要就两个变量:</p>
<ul>
<li><code>map</code> ：用于存放最终数据的。</li>
<li><code>PRESENT</code> ：是所有写入 map 的 <code>value</code> 值。</li>
</ul>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造函数很简单，利用了 <code>HashMap</code> 初始化了 <code>map</code> 。</p>
<h4 id="add"><a href="#add" class="headerlink" title="add()"></a>add()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比较关键的就是这个 <code>add()</code> 方法。 可以看出它是将存放的对象当做了 <code>HashMap</code> 的健，<code>value</code> 都是相同的 <code>PRESENT</code> 。由于 <code>HashMap</code> 的 <code>key</code> 是不能重复的，所以每当有重复的值写入到 <code>HashSet</code> 时，<code>value</code> 会被覆盖，但 <code>key</code> 不会收到影响，这样就保证了 <code>HashSet</code> 中只能存放不重复的元素。</p>
<h3 id="LinkedHashMap经典用法"><a href="#LinkedHashMap经典用法" class="headerlink" title="LinkedHashMap经典用法"></a>LinkedHashMap经典用法</h3><p>LinkedHashMap 除了可以保证迭代顺序外，还有一个非常有用的用法：可以轻松实现一个采用了FIFO替换策略的缓存。具体说来，LinkedHashMap 有一个子类方法 <code>protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest)</code>，该方法的作用是告诉 Map 是否要删除“最老”的 Entry，所谓最老就是当前 Map 中最早插入的 Entry，如果该方法返回 true，最老的那个元素就会被删除。在每次插入新元素的之后 LinkedHashMap 会自动询问 removeEldestEntry() 是否要删除最老的元素。这样只需要在子类中重载该方法，当元素个数超过一定数量时让 removeEldestEntry() 返回 true，就能够实现一个固定大小的 FIFO 策略的缓存。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 一个固定大小的FIFO替换策略的缓存 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FIFOCache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> cacheSize;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FIFOCache</span><span class="params">(<span class="keyword">int</span> cacheSize)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cacheSize = cacheSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当Entry个数超过cacheSize时，删除最老的Entry</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> size() &gt; cacheSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="容器中的设计模式"><a href="#容器中的设计模式" class="headerlink" title="容器中的设计模式"></a>容器中的设计模式</h3><h4 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h4><p><img src="http://r.photo.store.qq.com/psb?/932c31e8-a24c-44e8-b0eb-07a959965080/t4Zntx2MjRsXdqDaiF3x9Y*DX.1.4okbpt5nS7EL3tA!/r/dDIBAAAAAAAA" alt="迭代器模式"></p>
<p>Collection 实现了 Iterable 接口，其中的 iterator() 方法能够产生一个 Iterator 对象，通过这个对象就可以迭代遍历 Collection 中的元素。</p>
<p>从 JDK 1.5 之后可以使用 foreach 方法来遍历实现了 Iterable 接口的聚合对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="string">"a"</span>);</span><br><span class="line">list.add(<span class="string">"b"</span>);</span><br><span class="line"><span class="keyword">for</span> (String item : list) &#123;</span><br><span class="line">    System.out.println(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h4><p>java.util.Arrays.asList() 可以把数组类型转换为 List 类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SafeVarargs</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">asList</span><span class="params">(T... a)</span></span></span><br></pre></td></tr></table></figure>
<p>如果要将数组类型转换为 List 类型，应该注意的是 asList() 的参数为泛型的变长参数，因此不能使用基本类型数组作为参数，只能使用相应的包装类型数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">List list = Arrays.asList(arr);</span><br></pre></td></tr></table></figure>
<p>也可以使用以下方式生成 List。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<h3 id="面试指南"><a href="#面试指南" class="headerlink" title="面试指南"></a>面试指南</h3><h4 id="1-ArrayList和LinkedList区别"><a href="#1-ArrayList和LinkedList区别" class="headerlink" title="1. ArrayList和LinkedList区别"></a>1. ArrayList和LinkedList区别</h4><ul>
<li>ArrayList 和 LinkedList 可想从名字分析，它们一个是 Array (动态数组) 的数据结构，一个是 Link (链表) 的数据结构，此外，它们两个都是对 List 接口的实现。前者是数组队列，相当于动态数组；后者为双向链表结构，也可当作堆栈、队列、双端队列；</li>
<li><strong>当随机访问 List 时</strong>（get和set操作），ArrayList 比 LinkedList的效率更高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找；</li>
<li><strong>当对数据进行增加和删除的操作时</strong>（add 和 remove 操作），LinkedList 比 ArrayList 的效率更高，因为 ArrayList 是数组，所以在其中进行增删操作时，会对操作点之后所有数据的下标索引造成影响，需要进行数据的移动；</li>
<li><strong>从利用效率来看</strong>，ArrayList 自由性较低，因为它需要手动的设置固定大小的容量，但是它的使用比较方便，只需要创建，然后添加数据，通过调用下标进行使用；而 LinkedList 自由性较高，能够动态的随数据量的变化而变化，但是它不便于使用；</li>
<li>ArrayList 主要空间开销在于需要在 List 列表预留一定空间；而 LinkList 主要控件开销在于需要存储结点信息以及结点指针信息。</li>
</ul>
<ul>
<li><strong>ArrayList、LinkedList 和 Vector如何选择？</strong><ul>
<li>当对数据的主要操作为索引或只在集合的末端增加、删除元素时，使用 ArrayList 或 Vector 效率比较高；</li>
<li>当对数据的操作主要为制定位置的插入或删除操作时，使用 LinkedList 效率比较高；</li>
<li>当在多线程中使用容器时（即多个线程会同时访问该容器），选用 Vector 较为安全；</li>
</ul>
</li>
</ul>
<h4 id="2-HashMap和HashTable区别，HashMap的key类型"><a href="#2-HashMap和HashTable区别，HashMap的key类型" class="headerlink" title="2. HashMap和HashTable区别，HashMap的key类型"></a>2. HashMap和HashTable区别，HashMap的key类型</h4><ul>
<li><p><strong>Hash Map和HashTable的区别</strong>  </p>
<ul>
<li>Hashtable 的方法是同步的，HashMap 非同步，所以在多线程场合要手动同步</li>
<li>Hashtable 不允许 null 值 (key 和 value 都不可以)，HashMap 允许 null 值( key 和 value 都可以)。 </li>
<li><p>两者的遍历方式大同小异，Hashtable 仅仅比 HashMap 多一个 elements 方法。 </p>
</li>
<li><p>Hashtable 和 HashMap 都能通过 values() 方法返回一个 Collection ，然后进行遍历处理。 </p>
</li>
<li><p>两者也都可以通过 entrySet() 方法返回一个 Set ， 然后进行遍历处理。 </p>
</li>
<li><p>HashTable 使用 Enumeration，HashMap 使用 Iterator。 </p>
</li>
<li>哈希值的使用不同，Hashtable 直接使用对象的 hashCode。而 HashMap 重新计算hash值，而且用于代替求模。 </li>
<li>Hashtable 中 hash 数组默认大小是11，增加的方式是 old*2+1。HashMap 中 hash 数组的默认大小是16，而且一定是 2 的指数。 </li>
<li>HashTable 基于 Dictionary 类，而 HashMap 基于 AbstractMap 类 </li>
</ul>
</li>
<li><p><strong>HashMap中的key可以是任何对象或数据类型吗</strong> </p>
<ul>
<li>可以为null，但不能是可变对象，如果是可变对象的话，对象中的属性改变，则对象 HashCode 也进行相应的改变，导致下次无法查找到已存在Map中的数据。 </li>
<li>如果可变对象在 HashMap 中被用作键，那就要小心在改变对象状态的时候，不要改变它的哈希值了。我们只需要保证成员变量的改变能保证该对象的哈希值不变即可。 </li>
</ul>
</li>
<li><p><strong>HashTable是线程安全的么</strong> </p>
<ul>
<li>HashTable 是线程安全的，其实现是在对应的方法上添加了 synchronized 关键字进行修饰，由于在执行此方法的时候需要获得对象锁，则执行起来比较慢。所以现在如果为了保证线程安全的话，使用 CurrentHashMap。 </li>
</ul>
</li>
</ul>
<h4 id="3-HashMap和ConcurrentHashMap"><a href="#3-HashMap和ConcurrentHashMap" class="headerlink" title="3. HashMap和ConcurrentHashMap"></a>3. HashMap和ConcurrentHashMap</h4><ul>
<li><strong>HashMap和Concurrent HashMap区别？</strong> <ul>
<li>HashMa p是非线程安全的，CurrentHashMap 是线程安全的。 </li>
<li>ConcurrentHashMap 将整个 Hash 桶进行了分段 segment，也就是将这个大的数组分成了几个小的片段segment，而且每个小的片段 segment 上面都有锁存在，那么在插入元素的时候就需要先找到应该插入到哪一个片段 segment，然后再在这个片段上面进行插入，而且这里还需要获取 segment 锁。 </li>
<li>ConcurrentHashMap 让锁的粒度更精细一些，并发性能更好。 </li>
</ul>
</li>
<li><strong>ConcurrentHashMap 线程安全吗， ConcurrentHashMap如何保证 线程安全？</strong> <ul>
<li>HashTable 容器在竞争激烈的并发环境下表现出效率低下的原因是所有访问 HashTable 的线程都必须竞争同一把锁，那假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率，这就是 ConcurrentHashMap 所使用的<strong>分段锁</strong>，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。 </li>
<li>get 操作的高效之处在于整个 get 过程不需要加锁，除非读到的值是空的才会加锁重读。<strong>get 方法里将要使用的共享变量都定义成 volatile</strong>，如用于统计当前 Segement 大小的 count 字段和用于存储值的 HashEntry 的 value。定义成 volatile 的变量，能够在线程之间保持可见性，能够被多线程同时读，并且保证不会读到过期的值，但是只能被单线程写（有一种情况可以被多线程写，就是写入的值不依赖于原值），在 get 操作里只需要读不需要写共享变量 count 和 value，所以可以不用加锁。 </li>
<li>put 方法首先定位到 Segment，然后在 Segment 里进行插入操作。<ul>
<li>插入操作需要经历两个步骤：（1）判断是否需要对 Segment 里的 HashEntry 数组进行扩容；（2）定位添加元素的位置然后放在HashEntry数组里。 </li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="4-Hashtable的原理"><a href="#4-Hashtable的原理" class="headerlink" title="4. Hashtable的原理"></a>4. Hashtable的原理</h4><p>Hashtable 使用链地址法进行元素存储，关键字：链地址，头插法。</p>
<p><strong>Hashtable 与 HashMap 的简单比较</strong></p>
<ol>
<li>HashTable 基于 Dictionary 类，而 HashMap 是基于 AbstractMap。Dictionary 是任何可将键映射到相应值的类的抽象父类，而 AbstractMap 是基于 Map 接口的实现，它以最大限度地减少实现此接口所需的工作。</li>
<li>HashMap 的 key 和 value 都允许为 null，而 Hashtable 的 key 和 value 都不允许为 null。HashMap 遇到 key 为 null 的时候，调用 putForNullKey 方法进行处理，而对 value 没有处理；Hashtable遇到 null，直接返回 NullPointerException。</li>
<li><strong>Hashtable 方法是同步，而HashMap则不是</strong>。我们可以看一下源码，Hashtable 中的几乎所有的 public 的方法都是 synchronized 的，而有些方法也是在内部通过 synchronized 代码块来实现。所以有人一般都建议如果是涉及到多线程同步时采用 HashTable，没有涉及就采用 HashMap，但是在 Collections 类中存在一个静态方法：<strong>synchronizedMap()</strong>，该方法创建了一个线程安全的 Map 对象，并把它作为一个封装的对象来返回。</li>
</ol>
<p><strong>参考资料：</strong></p>
<ul>
<li><a href="http://wiki.jikexueyuan.com/project/java-collection/hashtable.html" target="_blank" rel="noopener">Hashtable 的实现原理 - Java 集合学习指南 - 极客学院Wiki</a></li>
</ul>
<h4 id="5-Hash冲突的解决办法"><a href="#5-Hash冲突的解决办法" class="headerlink" title="5. Hash冲突的解决办法"></a>5. Hash冲突的解决办法</h4><ul>
<li>链地址法</li>
<li>开放地址法（向后一位）<ul>
<li>线性探测</li>
<li>平方探测</li>
<li>二次哈希</li>
</ul>
</li>
<li>再哈希法</li>
</ul>
<h4 id="6-什么是迭代器"><a href="#6-什么是迭代器" class="headerlink" title="6. 什么是迭代器"></a>6. 什么是迭代器</h4><p>　　Java 集合框架的集合类，我们有时候称之为容器。容器的种类有很多种，比如 ArrayList、LinkedList、HashSet…，每种容器都有自己的特点，ArrayList 底层维护的是一个数组；LinkedList 是链表结构的；HashSet 依赖的是哈希表，每种容器都有自己特有的数据结构。</p>
<p>　　因为容器的内部结构不同，很多时候可能不知道该怎样去遍历一个容器中的元素。所以为了使对容器内元素的操作更为简单，Java 引入了迭代器模式！ </p>
<p>　　把访问逻辑从不同类型的集合类中抽取出来，从而避免向外部暴露集合的内部结构。</p>
<p>　　<strong>迭代器模式</strong>：就是提供一种方法对一个容器对象中的各个元素进行访问，而又不暴露该对象容器的内部细。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用迭代器遍历ArrayList集合</span></span><br><span class="line">    Iterator&lt;String&gt; listIt = list.iterator();</span><br><span class="line">    <span class="keyword">while</span>(listIt.hasNext())&#123;</span><br><span class="line">        System.out.println(listIt.hasNext());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用迭代器遍历Set集合</span></span><br><span class="line">    Iterator&lt;String&gt; setIt = set.iterator();</span><br><span class="line">    <span class="keyword">while</span>(setIt.hasNext())&#123;</span><br><span class="line">        System.out.println(listIt.hasNext());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用迭代器遍历LinkedList集合</span></span><br><span class="line">    Iterator&lt;String&gt; linkIt = linkList.iterator();</span><br><span class="line">    <span class="keyword">while</span>(linkIt.hasNext())&#123;</span><br><span class="line">        System.out.println(listIt.hasNext());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考资料：</p>
<ul>
<li><a href="https://www.cnblogs.com/zyuze/p/7726582.html" target="_blank" rel="noopener">深入理解Java中的迭代器 - Mr·Dragon - 博客园</a></li>
</ul>
<h4 id="7-构造相同hash的字符串进行攻击，这种情况应该怎么处理？JDK7如何处理"><a href="#7-构造相同hash的字符串进行攻击，这种情况应该怎么处理？JDK7如何处理" class="headerlink" title="7. 构造相同hash的字符串进行攻击，这种情况应该怎么处理？JDK7如何处理"></a>7. 构造相同hash的字符串进行攻击，这种情况应该怎么处理？JDK7如何处理</h4><p><strong>攻击原理：</strong></p>
<p>　　当客户端发送一个请求到服务器，如果该请求中带有参数，服务器端会将 参数名-参数值 作为 key-value 保存在 HashMap 中。如果有人恶意构造请求，在请求中加入大量相同 hash 值的 String 参数名（key），那么在服务器端用于存储这些 key-value 对的 HashMap 会被强行退化成链表，如图：</p>
<p><img src="http://r.photo.store.qq.com/psb?/932c31e8-a24c-44e8-b0eb-07a959965080/.DTFINp98MPSDbx82xqvaPbaIwYYCs7rjJ9qdOmIkFI!/r/dDQBAAAAAAAA" alt="Hash攻击"></p>
<p>如果数据量足够大，那么在查找，插入时会占用大量 CPU，达到拒绝服务攻击的目的。</p>
<p><strong>怎么处理</strong></p>
<ol>
<li>限制 POST 和 GET 请求的参数个数</li>
<li>限制 POST 请求的请求体大小</li>
<li>Web Application FireWall（WAF）</li>
</ol>
<p><strong>JDK7如何处理</strong></p>
<p>HashMap 会动态的使用一个专门 TreeMap 实现来替换掉它。</p>
<h4 id="8-Hashmap为什么大小是2的幂次"><a href="#8-Hashmap为什么大小是2的幂次" class="headerlink" title="8. Hashmap为什么大小是2的幂次"></a>8. Hashmap为什么大小是2的幂次</h4><p>首先来看一下 hashmap 的 put 方法的源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)                </span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);  <span class="comment">//将空key的Entry加入到table[0]中</span></span><br><span class="line">    <span class="keyword">int</span> hash = hash(key.hashCode());  <span class="comment">//计算key.hashcode()的hash值，hash函数由hashmap自己实现</span></span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);  <span class="comment">//获取将要存放的数组下标</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * for中的代码用于：当hash值相同且key相同的情况下，使用新值覆盖旧值（其实就是修改功能）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//注意：for循环在第一次执行时就会先判断条件</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K, V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="comment">//hash值相同且key相同的情况下，使用新值覆盖旧值</span></span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="comment">//e.recordAccess(this);</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;<span class="comment">//返回旧值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(hash, key, value, i);<span class="comment">//增加一个新的Entry到table[i]</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">//如果没有与传入的key相等的Entry，就返回null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * "按位与"来获取数组下标</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h &amp; (length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>hashmap 始终将自己的桶保持在2的幂次，这是为什么？indexFor这个方法解释了这个问题</strong></p>
<p>大家都知道计算机里面位运算是基本运算，位运算的效率是远远高于取余 % 运算的</p>
<p>举个例子：2的幂次 转换成二进制就是 1+n 个 0，减 1 之后就是 0+n个1，如16 -&gt; 10000，15 -&gt; 01111</p>
<p>那么根据 &amp; 位运算的规则，都为 1 (真)时，才为 1，那 0≤运算后的结果≤15，假设 h &lt;= 15，那么运算后的结果就是 h 本身，h &gt;15，运算后的结果就是最后四位二进制做 &amp; 运算后的值，最终，就是 % 运算后的余数。</p>
<p>当容量一定是 2的幂次时，h &amp; (length - 1) == h % length</p>
</div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java基础/">Java基础</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="http://r.photo.store.qq.com/psb?/1dbb9f7e-a947-470f-9051-8b79e39c489a/stGwyjKcMBnywN.U5oDVxhfR8PuH2eEtmqs*eKZTAt8!/r/dDUBAAAAAAAA"><div class="post-qr-code__desc">我的帅照</div></div></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2018/09/25/计算机网络基础/"><i class="fa fa-chevron-left">  </i><span>计算机网络基础</span></a></div><div class="next-post pull-right"><a href="/2018/09/19/Java基础面试题（二）/"><span>Java基础面试题（二）</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2016 - 2018 By LSB - imdangerous@163.com</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.6"></script><script src="/js/fancybox.js?version=1.5.6"></script><script src="/js/sidebar.js?version=1.5.6"></script><script src="/js/copy.js?version=1.5.6"></script><script src="/js/fireworks.js?version=1.5.6"></script><script src="/js/transition.js?version=1.5.6"></script><script src="/js/scroll.js?version=1.5.6"></script><script src="/js/head.js?version=1.5.6"></script></body></html>